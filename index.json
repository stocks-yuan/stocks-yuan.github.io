[{"content":"","date":"24 February 2025","externalUrl":null,"permalink":"/categories/blog/","section":"Categories","summary":"","title":"Blog","type":"categories"},{"content":"","date":"24 February 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"24 February 2025","externalUrl":null,"permalink":"/","section":"Stocks-yuan Blog","summary":"","title":"Stocks-yuan Blog","type":"page"},{"content":" 问题描述 # 在ubuntu系统中实现两个URsim机械臂仿真器，要求主机和两个ursim在同一网段内。\n解决方案 # Docker Compose 简介 # Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。通过一个 YAML 文件（通常命名为 docker-compose.yml），你可以配置应用程序所需的服务、网络和卷等资源，并使用一条命令启动所有服务。\n核心功能 # 多容器管理：允许你在单个文件中定义多个容器及其配置。 服务依赖：可以指定服务启动顺序，确保依赖服务先启动。 环境变量：支持通过环境变量进行配置。 网络和卷管理：方便地定义网络和卷，供容器使用。 一键启停：通过 docker-compose up 和 docker-compose down 快速启动和停止所有服务。 步骤 # 调用docker pull命令应该可以从docker hub中拉取镜像 docker pull universalrobots/ursim_cb3 docker pull universalrobots/ursim_e-series 调用docker images命令检测镜像下载是否成功\n/home （或工作空间功能包下）创建文件夹\nmkdir dual_ursim \u0026amp;\u0026amp; cd dual_ursim 创建docker-compose.yml文件（以配置两个UR5机械臂为例）：\ntouch docker-compose.yml \u0026amp;\u0026amp; gedit docker-compose.yml # 指定 Docker Compose 文件的版本 version: \u0026#34;3\u0026#34; # 定义服务（容器） services: # 定义名为 leftArm 的服务 leftArm: # 使用 universalrobots/ursim_cb3 镜像 image: universalrobots/ursim_cb3 # 设置环境变量，指定机器人模型为 UR5 environment: - ROBOT_MODEL=UR5 # 配置网络 networks: ursim_net: # 使用名为 ursim_net 的网络 ipv4_address: 10.5.0.5 # 为该服务分配静态 IP 地址(用户可自定义，但需要在ursim_net内) # 配置卷（将主机目录挂载到容器中） volumes: # 将主机目录(可自定义) /home/stocks/dual_ursim/urcaps 挂载到容器的 /urcaps 目录() - /home/stocks/dual_ursim/urcaps:/urcaps # 将主机目录(可自定义) /home/stocks/dual_ursim/programs_leftArm 挂载到容器的 /ursim/programs 目录 - /home/stocks/dual_ursim/programs_leftArm:/ursim/programs # 定义名为 rightArm 的服务 rightArm: # 使用 universalrobots/ursim_cb3 镜像 image: universalrobots/ursim_cb3 # 设置环境变量，指定机器人模型为 UR5 environment: - ROBOT_MODEL=UR5 # 配置网络 networks: ursim_net: # 使用名为 ursim_net 的网络 ipv4_address: 10.5.0.6 # 为该服务分配静态 IP 地址(用户可自定义，但需要在ursim_net内) # 配置卷（将主机目录挂载到容器中） volumes: # 将主机目录(可自定义) /home/stocks/dual_ursim/urcaps 挂载到容器的 /urcaps 目录 - /home/stocks/dual_ursim/urcaps:/urcaps # 将主机目录(可自定义) /home/stocks/dual_ursim/programs_rightArm 挂载到容器的 /ursim/programs 目录 - /home/stocks/dual_ursim/programs_rightArm:/ursim/programs # 定义网络 networks: ursim_net: # 定义名为 ursim_net 的网络 driver: bridge # 使用桥接模式 ipam: # IP 地址管理配置 config: - subnet: 10.5.0.0/24 # 指定子网范围(用户可自定义) 启动容器 docker-compose -p dual_ursim -f docker-compose.yml up ","date":"24 February 2025","externalUrl":null,"permalink":"/blog/dual_ursim/","section":"Blog","summary":"","title":"UR双臂仿真(Dual_URSIM)解决方案","type":"blog"},{"content":" 1. MoveIt Plugin Interfaces # MoveIt2涉及到多个不同的领域，并提供了许多接口，以便让用户可以覆盖MoveIt2框架的不同部分和实现新的概念，而无需触碰该框架的核心。下面列出了MoveIt2中不同类型的插件，并概述了这些插件在该框架内的用途。\nmove_group::MoveGroupCapability kinematics::KinematicsBase planning_interface::PlannerManager planning_request_adapter::PlanningRequestAdapter moveit_controller_manager::MoveItControllerManager moveit_ros_control_interface::ControllerHandleAllocator moveit_sensor_manager::MoveItSensorManager constraint_samplers::ConstraintSamplerAllocator collision_detection::CollisionPlugin occupancy_map_monitor::OccupancyMapUpdater Movelt通过插件接口与运动规划器一起工作。这允许Movelt与来自多个库的不同运动规划器进行通信和使用，使Movelt易于扩展。Motion Planner 与move_group的接口是通过 ROS action或service（由move_group_node提供）实现的。\n2. Creating Motion Planner Plugin # 在本节中，我们将展示如何将一个新的运动规划器作为插件添加到 MoveIt 中。MoveIt 中的基类是planning_interface ，任何新的规划器插件都应该继承自该基类。为了演示目的，创建了一个线性插值规划器（lerp），它在关节空间中规划两个状态之间的运动。这个规划器可以作为添加任何新规划器的起点，因为它包含了必要的基础知识。本教程中涉及的最终源文件可在此处找到。\n. ├── CMakeLists.txt ├── include │ └── lerp_interface │ ├── lerp_interface.h\t#lerp_interface类 │ └── lerp_planning_context.h\t#lerp_planning_context类 ├── launch │ └── lerp_example.launch ├── lerp_interface_plugin_description.xml\t#插件描述 xml 文件 ├── lerp_planner.png └── src ├── lerp_example.cpp\t#加载和使用创建的 lerp 规划器 ├── lerp_interface.cpp\t#规划算法入口点(solve方法实现) ├── lerp_planner_manager.cpp\t#重写lerp_planner_manager类中方法 └── lerp_planning_context.cpp\t#重写lerp_planning_context类中方法 5 directories, 10 files 下图显示了在 MoveIt 中添加新规划器的类之间关系的简要总体视图。\nplanning_interface.h\n**PlannerConfigurationSettings：**配置运动规划插件中算法所需要的参数(可选) **PlanningContext：**运动规划插件的运行上下文，也就是具体调用算法的位置 PlanningManager： 运动规划插件管理器，用来注册新创建的运动规划插件 1.创建LERPPlanPlannerManager类 # class LERPPlannerManager : public planning_interface::PlannerManager 首先，我们在 moveit_tutorials 包中创建插件类。要为 lerp 创建插件类，请在 src 文件夹中创建一个名为 lerp_planner_manager.cpp 的文件。在此文件中， LERPPlanPlannerManager 覆盖了 planning_interface 中的 PlannerManager 类的函数。在此文件的末尾，我们需要将 LERPPlanPlannerManager 类注册为插件，这是通过 class_loader 中的 CLASS_LOADER_REGISTER_CLASS 宏完成的。\nlerp_planner_manager.cpp: # #include \u0026lt;moveit/planning_interface/planning_interface.h\u0026gt; // 包含MoveIt!规划接口头文件 #include \u0026lt;moveit/planning_interface/planning_response.h\u0026gt; // 包含MoveIt!规划响应头文件 #include \u0026lt;moveit/planning_scene/planning_scene.h\u0026gt; // 包含MoveIt!规划场景头文件 #include \u0026lt;moveit/collision_detection_fcl/collision_detector_allocator_fcl.h\u0026gt; // 包含FCL碰撞检测器分配器头文件 #include \u0026lt;class_loader/class_loader.hpp\u0026gt; // 包含类加载器头文件 #include \u0026#34;lerp_interface/lerp_planning_context.h\u0026#34; // 包含LERP规划上下文头文件 namespace lerp_interface // 定义命名空间lerp_interface { class LERPPlannerManager : public planning_interface::PlannerManager // 定义LERPPlannerManager类，继承自PlannerManager { public: LERPPlannerManager() : planning_interface::PlannerManager() // 构造函数 { } bool initialize(const moveit::core::RobotModelConstPtr\u0026amp; model, const std::string\u0026amp; /*ns*/) override // 初始化函数 { for (const std::string\u0026amp; gpName : model-\u0026gt;getJointModelGroupNames()) // 遍历机器人模型的关节组名称 { std::cout \u0026lt;\u0026lt; \u0026#34;group name \u0026#34; \u0026lt;\u0026lt; gpName \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; \u0026#34;robot model \u0026#34; \u0026lt;\u0026lt; model-\u0026gt;getName() \u0026lt;\u0026lt; std::endl; // 输出组名称和机器人模型名称 planning_contexts_[gpName] = LERPPlanningContextPtr(new LERPPlanningContext(\u0026#34;lerp_planning_context\u0026#34;, gpName, model)); // 创建LERP规划上下文并存储在map中 } return true; // 返回true表示初始化成功 } bool canServiceRequest(const moveit_msgs::MotionPlanRequest\u0026amp; req) const override // 检查是否可以处理请求 { return req.trajectory_constraints.constraints.empty(); // 如果轨迹约束为空，则返回true } std::string getDescription() const override // 获取描述 { return \u0026#34;LERP\u0026#34;; // 返回描述字符串 } void getPlanningAlgorithms(std::vector\u0026lt;std::string\u0026gt;\u0026amp; algs) const override // 获取规划算法 { algs.clear(); // 清空算法列表 algs.push_back(\u0026#34;lerp\u0026#34;); // 添加LERP算法 } planning_interface::PlanningContextPtr getPlanningContext(const planning_scene::PlanningSceneConstPtr\u0026amp; planning_scene, const planning_interface::MotionPlanRequest\u0026amp; req, moveit_msgs::MoveItErrorCodes\u0026amp; error_code) const override // 获取规划上下文 { error_code.val = moveit_msgs::MoveItErrorCodes::SUCCESS; // 设置错误码为成功 if (req.group_name.empty()) // 如果请求的组名称为空 { ROS_ERROR(\u0026#34;No group specified to plan for\u0026#34;); // 输出错误信息 error_code.val = moveit_msgs::MoveItErrorCodes::INVALID_GROUP_NAME; // 设置错误码为无效组名称 return planning_interface::PlanningContextPtr(); // 返回空指针 } if (!planning_scene) // 如果规划场景为空 { ROS_ERROR(\u0026#34;No planning scene supplied as input\u0026#34;); // 输出错误信息 error_code.val = moveit_msgs::MoveItErrorCodes::FAILURE; // 设置错误码为失败 return planning_interface::PlanningContextPtr(); // 返回空指针 } // 创建使用混合碰撞检测器的规划场景 planning_scene::PlanningScenePtr ps = planning_scene-\u0026gt;diff(); // 设置FCL为分配器 ps-\u0026gt;setActiveCollisionDetector(collision_detection::CollisionDetectorAllocatorFCL::create(), true); // 检索并配置现有上下文 const LERPPlanningContextPtr\u0026amp; context = planning_contexts_.at(req.group_name); ROS_INFO_STREAM_NAMED(\u0026#34;lerp_planner_manager\u0026#34;, \u0026#34;===\u0026gt;\u0026gt;\u0026gt; context is made \u0026#34;); // 输出信息 context-\u0026gt;setPlanningScene(ps); // 设置规划场景 context-\u0026gt;setMotionPlanRequest(req); // 设置运动规划请求 error_code.val = moveit_msgs::MoveItErrorCodes::SUCCESS; // 设置错误码为成功 return context; // 返回上下文 } protected: std::map\u0026lt;std::string, LERPPlanningContextPtr\u0026gt; planning_contexts_; // 规划上下文map }; } // namespace lerp_interface // 注册LERPPlannerManager类为插件 CLASS_LOADER_REGISTER_CLASS(lerp_interface::LERPPlannerManager, planning_interface::PlannerManager); 2.创建 LERPPlanningContext 类 # class LERPPlanningContext : public planning_interface::PlanningContext 接下来我们创建 LERPPlanningContext 类，该类将覆盖 PlanningContext 的功能。这个类将覆盖 solve 函数，其中规划器解决问题并返回解决方案。\nlerp_planning_context.h # #ifndef LERP_PLANNING_CONTEXT_H #define LERP_PLANNING_CONTEXT_H #include \u0026lt;moveit/planning_interface/planning_interface.h\u0026gt; #include \u0026#34;lerp_interface/lerp_interface.h\u0026#34; namespace lerp_interface { MOVEIT_CLASS_FORWARD(LERPPlanningContext); class LERPPlanningContext : public planning_interface::PlanningContext { public: LERPPlanningContext(const std::string\u0026amp; name, const std::string\u0026amp; group, const moveit::core::RobotModelConstPtr\u0026amp; model); ~LERPPlanningContext() override { } bool solve(planning_interface::MotionPlanResponse\u0026amp; res) override; bool solve(planning_interface::MotionPlanDetailedResponse\u0026amp; res) override; bool terminate() override; void clear() override; private: moveit::core::RobotModelConstPtr robot_model_; moveit::core::RobotStatePtr robot_state_; LERPInterfacePtr lerp_interface_; }; } // namespace lerp_interface #endif // LERP_PLANNING_CONTEXT_H 3.创建LERPInterface类 # 由于 solve 函数的实现可能需要许多来自规划器代码库的类，因此更具可读性的是创建另一个名为 LERPInterface 的类，其中将进行规划器 solve 方法的实际实现。实际上，这个类是新运动规划算法的入口点。\nlerp_interface.h # #pragma once #include \u0026lt;ros/ros.h\u0026gt; #include \u0026lt;moveit/planning_interface/planning_interface.h\u0026gt; namespace lerp_interface { MOVEIT_CLASS_FORWARD(LERPInterface); class LERPInterface { public: LERPInterface(const ros::NodeHandle\u0026amp; nh = ros::NodeHandle(\u0026#34;~\u0026#34;)); bool solve(const planning_scene::PlanningSceneConstPtr\u0026amp; planning_scene, const planning_interface::MotionPlanRequest\u0026amp; req, moveit_msgs::MotionPlanDetailedResponse\u0026amp; res); protected: ros::NodeHandle nh_; std::string name_; int num_steps_; int dof_; private: void interpolate(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; joint_names, moveit::core::RobotStatePtr\u0026amp; robot_state, const moveit::core::JointModelGroup* joint_model_group, const std::vector\u0026lt;double\u0026gt;\u0026amp; start_joint_vals, const std::vector\u0026lt;double\u0026gt;\u0026amp; goal_joint_vals, trajectory_msgs::JointTrajectory\u0026amp; joint_trajectory); }; } // namespace lerp_interface 4.PlannerConfigurationSettings # PlannerConfigurationSettings 可以用来传递特定于规划器的参数。另一种传递这些参数的方法是使用 ROS 参数服务器，该服务器从 yaml 文件中读取。在本教程中，对于我们的 lerp 规划器，我们在 panda_moveit_config 包中使用 lerp_planning.yaml ，该包仅包含一个参数 num_steps ，该参数在每次调用其 solve 函数时都会加载到 lerp_interface 中。\n5.Export the plugin # 首先，我们需要使插件可用于 ROS 工具链。为此，应创建一个包含以下选项的插件描述 xml 文件（ emptyplan_interface_plugin_description.xml ），其中包含 library 标签：\nemptyplan_interface_plugin_description.xml: # \u0026lt;library path=\u0026#34;libmoveit_lerp_planner_plugin\u0026#34;\u0026gt; \u0026lt;class name=\u0026#34;lerp_interface/LERPPlanner\u0026#34; type=\u0026#34;lerp_interface::LERPPlannerManager\u0026#34; base_class_type=\u0026#34;planning_interface::PlannerManager\u0026#34;\u0026gt; \u0026lt;description\u0026gt; The lerp motion planner plugin which interpolates between two given start and goal joint state values. \u0026lt;/description\u0026gt; \u0026lt;/class\u0026gt; \u0026lt;/library\u0026gt; package.xml: # \u0026lt;export\u0026gt; \u0026lt;moveit_core plugin=\u0026#34;${prefix}/doc/creating_moveit_plugins/lerp_motion_planner/lerp_interface_plugin_description.xml\u0026#34;/\u0026gt; \u0026lt;/export\u0026gt; 6.Check the plugin # 使用以下命令，可以验证新插件是否已正确创建和导出：\nrospack plugins --attrib=plugin moveit_core 结果应包含 moveit_planners_lerp 以及插件描述 xml 文件的地址：\nmoveit_tutorials \u0026lt;ros_workspace\u0026gt;/src/moveit_tutorials/creating_moveit_plugins/lerp_motion_planner/lerp_interface_plugin_description.xml 7.Plugin usage # 在本小节中，我们将**解释如何加载和使用我们之前创建的 lerp 规划器。**为此，创建了一个名为 lerp_example.cpp 的 node。\n第一步是通过以下代码行获取与请求的规划组以及规划场景相关的机器人的状态和关节组：\nmoveit::core::RobotStatePtr robot_state(new moveit::core::RobotState(robot_model)); const moveit::core::JointModelGroup* joint_model_group = robot_state-\u0026gt;getJointModelGroup(PLANNING_GROUP); const std::vector\u0026lt;std::string\u0026gt;\u0026amp; joint_names = joint_model_group-\u0026gt;getVariableNames(); planning_scene::PlanningScenePtr planning_scene(new planning_scene::PlanningScene(robot_model)); 下一步是使用 pluginlib 加载规划器，并将参数 planner_plugin_name 设置为我们创建的参数：\nboost::scoped_ptr\u0026lt;pluginlib::ClassLoader\u0026lt;planning_interface::PlannerManager\u0026gt;\u0026gt; planner_plugin_loader; planning_interface::PlannerManagerPtr planner_instance; std::string planner_plugin_name = \u0026#34;lerp_interface/LERPPlanner\u0026#34;; node_handle.setParam(\u0026#34;planning_plugin\u0026#34;, planner_plugin_name); 加载规划器后，是时候为运动规划问题设置起始状态和目标状态了。起始状态是机器人的当前状态，设置为 req.start_state 。另一方面，目标约束是通过使用目标状态和关节模型组创建 moveit_msgs::Constraints 来设置的。此约束被传递给 req.goal_constraint 。以下代码显示了如何执行这些步骤：\n// Get the joint values of the start state and set them in request.start_state std::vector\u0026lt;double\u0026gt; start_joint_values; robot_state-\u0026gt;copyJointGroupPositions(joint_model_group, start_joint_values); req.start_state.joint_state.position = start_joint_values; // Goal constraint moveit::core::RobotState goal_state(robot_model); std::vector\u0026lt;double\u0026gt; joint_values = { 0.8, 0.7, 1, 1.3, 1.9, 2.2, 3 }; goal_state.setJointGroupPositions(joint_model_group, joint_values); moveit_msgs::Constraints joint_goal = kinematic_constraints::constructGoalConstraints(goal_state, joint_model_group); req.goal_constraints.clear(); req.goal_constraints.push_back(joint_goal); 到目前为止，我们已经加载了规划器并为运动规划问题创建了起始状态和目标状态，但我们尚未解决该问题。通过给定的起始状态和目标状态信息，在关节状态下解决运动规划问题是通过创建一个 PlanningContext 实例并调用其 solve 函数来完成的。请记住，传递给此 solve 函数的响应应为 planning_interface::MotionPlanResponse 类型：\nplanning_interface::PlanningContextPtr context = planner_instance-\u0026gt;getPlanningContext(planning_scene, req, res.error_code_); 最后，要运行此节点，我们需要在启动文件夹中 roslaunch lerp_example.launch。此启动文件通过传递 lerp 作为规划器的名称来启动包 panda_moveit_config 的 demo.launch 。然后， lerp_example 被启动， lerp_planning.yaml 被加载以将 lerp 特定参数设置到 ROS 参数服务器。\n","date":"5 January 2025","externalUrl":null,"permalink":"/blog/moveit_plugins/","section":"Blog","summary":"","title":"Creating MoveIt Plugins","type":"blog"},{"content":" 1.Docker容器技术解决了什么问题 # Docker 解决了程序部署运行的问题。传统方式是直接将程序部署到物理服务器，而 Docker 则利用容器技术，将程序及其依赖环境打包成镜像，作为独立单元进行管理。Docker 提供了用户友好的界面，简化了操作，实现了“一次构建，随处运行”（build once, run anywhere）。它通过容器镜像标准化了软件交付，将软件部署的复杂性封装在镜像中，使用者无需关注内部细节，从而彻底改变了软件部署和分发模式\n🐳传统部署 # 直接管理业务程序的启停方便，但忽略了依赖管理。多台机器部署时，依赖复杂且易变，而且不同程序版本依赖冲突，导致部署繁琐且易出错。 解决思路是将程序及其所有依赖打包成一个独立单元，例如每个程序版本独占一台机器，这个机器完全为这个程序服务， 从而简化部署和管理。\n🚀虚拟机部署 # 为解决程序版本和依赖冲突，最初采用虚拟机部署方案，将程序及其依赖打包到虚拟机镜像中。但虚拟机镜像庞大、启动慢、性能损耗大，成本和效率低。因此，未来的目标是在解决依赖问题的同时，克服虚拟机部署的缺点，寻求更优的方案。\n🚀解决第一个问题——储存过大(镜像过大) # 容器技术源于轻量级虚拟机的思路，旨在解决虚拟机镜像过大的问题。其核心是利用多个虚拟机或虚拟机与宿主机操作系统间大量重复文件的特性，通过Copy-on-Write机制，即只保存一份共享文件，修改时再复制给做出修改的虚拟机，从而节省存储空间。\n🚀解决第二个问题——启停过慢 # 虚拟机之所以启停速度慢，是因为虚拟机的启动和停止速度比容器技术慢的原因主要在于：虚拟机启停包含了整个操作系统的启动流程；容器启停相当于进程级别的启停。每次启动或停止虚拟机时，都需要经历操作系统的启动和关闭过程，这增加了额外的时间开销。\n相比之下，容器技术在保持隔离的前提下，只需要启动程序进程本身，不需要启动整个操作系统，因此启停速度明显更快。容器技术利用了namespace和c groups等隔离技术，这些技术在2008年已经基本发展成型，早于Docker等容器技术的出现。通过这些轻量化的隔离手段，容器技术能够解耦操作系统本身冗余的部分，只关注进程本身的启动和停止，从而提高了启停速度。\n此外，容器内的进程共用内核，不需要维护独立的内核，减少了重复和冗余的开销，进一步降低了性能损耗。而虚拟机技术在硬件层面的损耗也较大，早期的虚拟机技术在这方面的损耗尤为明显。\n总结来说，虚拟机的启停速度慢主要是因为包含了操作系统的启动和关闭过程，而容器技术通过轻量化的隔离手段和共用OS内核的方式，显著提高了启停速度。\n🚀解决第三个问题——性能损耗 # **容器技术通过共用宿主机的内核来解决性能损耗问题。具体来说，容器内的所有进程共享宿主机的操作系统内核，不需要为每个容器维护独立的内核，从而消除了重复和冗余的开销。这种轻量化的方式减少了操作系统层面上的行为重复和冗余，降低了硬件资源的使用损耗，进而提高了程序的性能，这是软件虚拟化损耗，而对于硬件虚拟化损耗，**虽然早期硬件虚拟化存在损耗，但随着技术发展，这些损耗已大幅降低，最终可望完全消除，标志着容器技术的成熟。\n2.容器与虚拟机(VM) # 技术 虚拟化对象 Docker容器 操作系统级别的虚拟化：容器虚拟化的是操作系统内的用户空间，直接共享宿主机的内核。 虚拟机 硬件级别的虚拟化：虚拟化的是整个硬件资源，运行自己的完整操作系统，包括内核和应用。 容器和虚拟机具有类似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。\nCONTAINERS # 容器是应用程序层的抽象，它将代码和依赖关系打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。容器比虚拟机占用更少的空间（容器映像的大小通常为几十Mb），可以处理更多的应用程序，并且需要更少的虚拟机和操作系统。\nVIRTUAL MACHINES # 虚拟机（vm）是物理硬件的抽象，可以将一个服务器转换为多个服务器。管理程序允许在一台机器上运行多个虚拟机。每个VM包括操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十GB的空间。虚拟机也可能启动缓慢。\n镜像庞大 （数十GB）\n启停速度慢\n性能损耗大\n3.Docker镜像 # 容器是一个标准的软件单元，它将代码及其所有依赖项打包，以便应用程序从一个计算环境快速可靠地运行到另一个计算环境。\nDocker容器镜像是一个轻量级的、独立的、可执行的软件包，它包含了运行应用程序所需的一切：代码、运行时间、系统工具、系统库和设置。\n以Docker容器为例——当映像在Docker引擎上运行时，它们就变成了容器。容器化软件可用于Linux和基于windows的应用程序，无论基础设施如何，都将始终以相同的方式运行。容器将软件从它的环境中隔离出来，并确保它能够统一地工作，尽管在开发和阶段之间存在差异。\n镜像有两个重要的原则：\n图像是不可变的。图像一旦创建就无法修改。您只能制作新图像或在其上添加更改。 容器镜像由层组成。每个层代表一组添加、删除或修改文件的文件系统更改 在Docker引擎上运行的Docker容器：\n标准：Docker为容器创建了行业标准，因此它们可以移植到任何地方\n轻量级：容器共享机器的操作系统内核，因此不需要每个应用程序一个操作系统，从而提高了服务器效率，降低了服务器和许可成本\n安全：容器中的应用程序更安全，Docker提供了业界最强的默认隔离功能\n4.dcoker注册表 # 现在您已经知道什么是容器映像以及它是如何工作的，您可能想知道 - 将这些映像存储在哪里？\n镜像注册表是用于存储和共享容器镜像的集中位置。它可以是公共的或私人的。 Docker Hub是一个任何人都可以使用的公共注册表，并且是默认注册表。\n注册表与存储库 # 当您使用注册表时，您可能会听到注册表和存储库这两个术语，就好像它们是可以互换的一样。尽管它们有相关性，但它们并不完全相同。\n注册表是存储和管理容器映像的集中位置，而存储库是注册表中相关容器映像的集合。将其视为一个文件夹，您可以在其中根据项目组织图像。每个存储库都包含一个或多个容器映像。\n5.Docker Compose # 如果您运行多个容器，如何将它们连接在一起？\n**容器的一个最佳实践是每个容器应该做一件事并且做好。**尽管这一规则也有例外，但请避免让一个容器执行多项操作的趋势。\n您可以使用多个docker run命令来启动多个容器。但是，您很快就会意识到您需要管理网络、将容器连接到这些网络所需的所有标志等等。完成后，清理工作会稍微复杂一些。\n使用 Docker Compose，您可以在单个 YAML 文件中定义所有容器及其配置。如果您将此文件包含在代码存储库中，则克隆您的存储库的任何人都可以使用单个命令启动并运行。\n重要的是要理解 Compose 是一个声明性工具 - 您只需定义它并运行即可。您并不总是需要从头开始重新创建所有内容。如果您进行了更改，请docker compose up再次运行，Compose 将协调文件中的更改并智能地应用它们。\n","date":"2 January 2025","externalUrl":null,"permalink":"/blog/blog-docker/","section":"Blog","summary":"","title":"Docker(build once, run anywhere) ","type":"blog"},{"content":" 1. DH参数与坐标系 # 标准DH参数的连杆坐标系建立在传动轴，改进DH参数的连杆坐标系建立在驱动轴，对于UR5这类串联型机械臂，这两种DH参数法没有优劣之分。\n1.1 UR5 Standard DH Parameter # (for other model please click here)\nKinematics $\\theta_i$ [rad] \\(a_i\\) [m] \\(d_i\\) [m] \\(\\alpha_i\\) [rad] Joint 1 0 0 0.089159 π/2 Joint 2 0 -0.42500 0 0 Joint 3 0 -0.39225 0 0 Joint 4 0 0 0.10915 π/2 Joint 5 0 0 0.09465 -π/2 Joint 6 0 0 0.0823 0 MatLab程序：\n% startup_rvc clear;clc; %UR5 standard_DH parameter a=[0,-0.42500,-0.39225,0,0,0]; d=[0.089159,0,0,0.10915,0.09465,0.08230]; alpha=[pi/2,0,0,pi/2,-pi/2,0]; % 建立UR5机械臂模型 L1 = Link(\u0026#39;d\u0026#39;, d(1), \u0026#39;a\u0026#39;, a(1), \u0026#39;alpha\u0026#39;, alpha(1), \u0026#39;standard\u0026#39;); L2 = Link(\u0026#39;d\u0026#39;, d(2), \u0026#39;a\u0026#39;, a(2), \u0026#39;alpha\u0026#39;, alpha(2), \u0026#39;standard\u0026#39;); L3 = Link(\u0026#39;d\u0026#39;, d(3), \u0026#39;a\u0026#39;, a(3), \u0026#39;alpha\u0026#39;, alpha(3), \u0026#39;standard\u0026#39;); L4 = Link(\u0026#39;d\u0026#39;, d(4), \u0026#39;a\u0026#39;, a(4), \u0026#39;alpha\u0026#39;, alpha(4), \u0026#39;standard\u0026#39;); L5 = Link(\u0026#39;d\u0026#39;, d(5), \u0026#39;a\u0026#39;, a(5), \u0026#39;alpha\u0026#39;, alpha(5), \u0026#39;standard\u0026#39;); L6 = Link(\u0026#39;d\u0026#39;, d(6), \u0026#39;a\u0026#39;, a(6), \u0026#39;alpha\u0026#39;, alpha(6), \u0026#39;standard\u0026#39;); tool_robot = SerialLink([L1,L2,L3,L4,L5,L6], \u0026#39;name\u0026#39;, \u0026#39;UR5\u0026#39;); tool_robot.display(); view(3); tool_robot.teach(); UR5机械臂模型：\n1.2 UR5 Modify DH Parameter # Kinematics $\\theta_i$ [rad] $a_{i-1}$ [m] $d_i$ [m] $\\alpha_{i-1}$ [rad] Joint 1 0 0 0.089159 0 Joint 2 0 0 0 π/2 Joint 3 0 -0.42500 0 0 Joint 4 0 -0.39225 0.10915 0 Joint 5 0 0 0.09465 π/2 Joint 6 0 0 0.08230 -π/2 2. Forward kinematics # 正运动学：已知机械臂六个关节角度求变换矩阵T\n2.1 正运动学解算(标准DH参数) # $$ _{i}^{i-1}T = \\text{Rot}(z, \\theta_i) \\cdot \\text{Trans}(0, 0, d_i) \\cdot \\text{Rot}(x, \\alpha_i) \\cdot \\text{Trans}(a_i, 0, 0) $$整理得：\n$$ _{i}^{i-1}T = \\begin{pmatrix} \\cos(\\theta_{i}) \u0026 -\\sin(\\theta_{i}) \u0026 0 \u0026 0 \\\\ \\sin(\\theta_{i}) \u0026 \\cos(\\theta_{i}) \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix} \\begin{pmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 \\text{d}_{i} \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix} \\begin{pmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\cos(\\alpha_{i}) \u0026 -\\sin(\\alpha_{i}) \u0026 0 \\\\ 0 \u0026 \\sin(\\alpha_{i}) \u0026 \\cos(\\alpha_{i}) \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix} \\begin{pmatrix} 1 \u0026 0 \u0026 0 \u0026 a_{i} \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix} $$整理得：\n$$ _{i}^{i-1}T=\\begin{bmatrix}\\cos(\\theta_i)\u0026-\\sin(\\theta_i)\\cos(\\alpha_{i})\u0026\\sin(\\theta_i)\\sin(\\alpha_{i})\u0026a_{i}\\cos(\\theta_i)\\\\\\sin(\\theta_i)\u0026\\cos(\\theta_i)\\cos(\\alpha_{i})\u0026-\\cos(\\theta_i)\\sin(\\alpha_{i})\u0026a_{i}\\sin(\\theta_i)\\\\0\u0026\\sin(\\alpha_{i})\u0026\\cos(\\alpha_{i})\u0026d_i\\\\0\u00260\u00260\u00261\\end{bmatrix} $$机械臂末端坐标系 6 相对笛卡尔基坐标系 0 的齐次变换矩阵$_{6}^{0}T $：\n$$ _{6}^{0}T = _{1}^{0}T \\cdot _{2}^{1}T \\cdot _{3}^{2}T \\cdot_{4}^{3}T \\cdot_{5}^{4}T \\cdot _{6}^{5}T $$整理得正运动学方程：\n$$ _{6}^{0}T =\\begin{bmatrix} n_x \u0026 o_x \u0026 a_x \u0026 p_x \\\\n_y \u0026 o_y \u0026 a_y \u0026 p_y\\\\n_z \u0026 o_z \u0026 a_z \u0026 p_z\\\\0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$其中：\n$$ \\begin{cases} n_x = \\cos\\left(\\theta _{6}\\right)\\,\\left(\\sin\\left(\\theta _{1}\\right)\\,\\sin\\left(\\theta _{5}\\right)+\\cos\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\cos\\left(\\theta _{1}\\right)\\,\\cos\\left(\\theta _{5}\\right)\\right)-\\sin\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\cos\\left(\\theta _{1}\\right)\\,\\sin\\left(\\theta _{6}\\right) \\\\ n_y = -\\cos\\left(\\theta _{6}\\right)\\,\\left(\\cos\\left(\\theta _{1}\\right)\\,\\sin\\left(\\theta _{5}\\right)-\\cos\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\cos\\left(\\theta _{5}\\right)\\,\\sin\\left(\\theta _{1}\\right)\\right)-\\sin\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\sin\\left(\\theta _{1}\\right)\\,\\sin\\left(\\theta _{6}\\right) \\\\ n_z = \\cos\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\sin\\left(\\theta _{6}\\right)+\\sin\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\cos\\left(\\theta _{5}\\right)\\,\\cos\\left(\\theta _{6}\\right) \\end{cases} $$$$ \\begin{cases} o_x = -\\sin\\left(\\theta _{6}\\right)\\,\\left(\\sin\\left(\\theta _{1}\\right)\\,\\sin\\left(\\theta _{5}\\right)+\\cos\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\cos\\left(\\theta _{1}\\right)\\,\\cos\\left(\\theta _{5}\\right)\\right)-\\sin\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\cos\\left(\\theta _{1}\\right)\\,\\cos\\left(\\theta _{6}\\right) \\\\ o_y = \\sin\\left(\\theta _{6}\\right)\\,\\left(\\cos\\left(\\theta _{1}\\right)\\,\\sin\\left(\\theta _{5}\\right)-\\cos\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\cos\\left(\\theta _{5}\\right)\\,\\sin\\left(\\theta _{1}\\right)\\right)-\\sin\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\cos\\left(\\theta _{6}\\right)\\,\\sin\\left(\\theta _{1}\\right) \\\\ o_z = \\cos\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\cos\\left(\\theta _{6}\\right)-\\sin\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\cos\\left(\\theta _{5}\\right)\\,\\sin\\left(\\theta _{6}\\right) \\end{cases} $$$$ \\begin{cases} a_x = \\cos\\left(\\theta _{5}\\right)\\,\\sin\\left(\\theta _{1}\\right)-\\cos\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\cos\\left(\\theta _{1}\\right)\\,\\sin\\left(\\theta _{5}\\right) \\\\ a_y = -\\cos\\left(\\theta _{1}\\right)\\,\\cos\\left(\\theta _{5}\\right)-\\cos\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\sin\\left(\\theta _{1}\\right)\\,\\sin\\left(\\theta _{5}\\right) \\\\ a_z = -\\sin\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\sin\\left(\\theta _{5}\\right) \\end{cases} $$$$ \\begin{cases} p_x = d_{6}\\,\\left(\\cos\\left(\\theta _{5}\\right)\\,\\sin\\left(\\theta _{1}\\right)-\\cos\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\cos\\left(\\theta _{1}\\right)\\,\\sin\\left(\\theta _{5}\\right)\\right)+d_{4}\\,\\sin\\left(\\theta _{1}\\right)+a_{2}\\,\\cos\\left(\\theta _{1}\\right)\\,\\cos\\left(\\theta _{2}\\right)+d_{5}\\,\\sin\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\cos\\left(\\theta _{1}\\right)+a_{3}\\,\\cos\\left(\\theta _{1}\\right)\\,\\cos\\left(\\theta _{2}\\right)\\,\\cos\\left(\\theta _{3}\\right)-a_{3}\\,\\cos\\left(\\theta _{1}\\right)\\,\\sin\\left(\\theta _{2}\\right)\\,\\sin\\left(\\theta _{3}\\right) \\\\ p_y = a_{2}\\,\\cos\\left(\\theta _{2}\\right)\\,\\sin\\left(\\theta _{1}\\right)-d_{4}\\,\\cos\\left(\\theta _{1}\\right)-d_{6}\\,\\left(\\cos\\left(\\theta _{1}\\right)\\,\\cos\\left(\\theta _{5}\\right)+\\cos\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\sin\\left(\\theta _{1}\\right)\\,\\sin\\left(\\theta _{5}\\right)\\right)+d_{5}\\,\\sin\\left(\\theta _{2}+\\theta _{3}+\\theta _{4}\\right)\\,\\sin\\left(\\theta _{1}\\right)+a_{3}\\,\\cos\\left(\\theta _{2}\\right)\\,\\cos\\left(\\theta _{3}\\right)\\,\\sin\\left(\\theta _{1}\\right)-a_{3}\\,\\sin\\left(\\theta _{1}\\right)\\,\\sin\\left(\\theta _{2}\\right)\\,\\sin\\left(\\theta _{3}\\right) \\\\ p_z = d_{1}+d_{5}\\,\\left(\\sin\\left(\\theta _{2}+\\theta _{3}\\right)\\,\\sin\\left(\\theta _{4}\\right)-\\cos\\left(\\theta _{2}+\\theta _{3}\\right)\\,\\cos\\left(\\theta _{4}\\right)\\right)+a_{3}\\,\\sin\\left(\\theta _{2}+\\theta _{3}\\right)+a_{2}\\,\\sin\\left(\\theta _{2}\\right)-d_{6}\\,\\sin\\left(\\theta _{5}\\right)\\,\\left(\\cos\\left(\\theta _{2}+\\theta _{3}\\right)\\,\\sin\\left(\\theta _{4}\\right)+\\sin\\left(\\theta _{2}+\\theta _{3}\\right)\\,\\cos\\left(\\theta _{4}\\right)\\right) \\end{cases} $$$_{6}^{0}T $计算程序：\nsyms theta1 theta2 theta3 theta4 theta5 theta6 d1 d4 d5 d6 a2 a3 t01 = [cos(theta1), 0, sin(theta1), 0; sin(theta1), 0, -cos(theta1), 0; 0, 1, 0, d1; 0, 0, 0, 1]; t12 = [cos(theta2), -sin(theta2), 0, a2 * cos(theta2); sin(theta2), cos(theta2), 0, a2 * sin(theta2); 0, 0, 1, 0; 0, 0, 0, 1]; t23 = [cos(theta3), -sin(theta3), 0, a3 * cos(theta3); sin(theta3), cos(theta3), 0, a3 * sin(theta3); 0, 0, 1, 0; 0, 0, 0, 1]; t34 = [cos(theta4), 0, sin(theta4), 0; sin(theta4), 0, -cos(theta4), 0; 0, 1, 0, d4; 0, 0, 0, 1]; t45 = [cos(theta5), 0, -sin(theta5), 0; sin(theta5), 0, cos(theta5), 0; 0, -1, 0, d5; 0, 0, 0, 1]; t56 = [cos(theta6), -sin(theta6), 0, 0; sin(theta6), cos(theta6), 0, 0; 0, 0, 1, d6; 0, 0, 0, 1]; T = simplify(t01 * t12 * t23 * t34 * t45 * t56); % 转换为 LaTeX 格式 latex_T = latex(T); % 输出结果 disp(latex_T); 2.2 MatLab仿真验证 # 2.2.1 Matlab程序 # function T = forward_kinematics(theta,d,a,alpha) %forward kenematics %input:theta(rad) %output:T % UR5 standard_DH parameter % a=[0,-0.42500,-0.39225,0,0,0]; % d=[0.089159,0,0,0.10915,0.09465,0.08230]; % alpha=[pi/2,0,0,pi/2,-pi/2,0]; T01=T_para(theta(1),d(1),a(1),alpha(1)); T12=T_para(theta(2),d(2),a(2),alpha(2)); T23=T_para(theta(3),d(3),a(3),alpha(3)); T34=T_para(theta(4),d(4),a(4),alpha(4)); T45=T_para(theta(5),d(5),a(5),alpha(5)); T56=T_para(theta(6),d(6),a(6),alpha(6)); T=T01*T12*T23*T34*T45*T56; % T = [nx ox ax px % ny oy ay py % nz oz az pz % 0 0 0 1 ] end 2.2.2 位姿验证 # UR仿真器\n程序输入：[ 93.14 , -62.68 ,108.27 , -135.56 , -66.46 , 15.59 ]\n$$ T =\\begin{bmatrix} \\color{yellow}-0.8965 \u0026 \\color{yellow}0.1933 \u0026 \\color{yellow}0.3988 \u0026 \\color{red}{0.1727}\\\\\\color{yellow}0.2202\u0026 \\color{yellow}0.9752 \u0026 \\color{yellow}0.0224 \u0026 \\color{red}{-0.5555}\\\\\\color{yellow}-0.3846 \u0026 \\color{yellow}0.1078 \u0026 \\color{yellow}-0.9168 \u0026 \\color{red}{0.1110}\\\\0 \u00260 \u0026 0 \u0026 1 \\end{bmatrix} $$ Matlab输出模型：\n位置验证：\n期望位置(mm): [ 172.69 , -555.55 , 111.06 ]\n解算位置(m):\t$p_x = 0.1727$ ; $p_y = 0.5555$ ; $p_z = 0.1110$\n姿态验证：\n期望姿态(rad):\t轴角[ 0.297 , 2.719 , 0.093 ]\n结算姿态(rad):\t旋转矩阵($n_{xyz}$ $o_{xyz}$ $a_{xyz}$ )—\u0026gt;轴角[ 0.2967251, 2.7186044, 0.0934307 ]\n$$ \\begin{bmatrix} n_{xyz}\u0026o_{xyz}\u0026a_{xyz} \\end{bmatrix} = \\begin{bmatrix} -0.8965 \u00260.1933 \u00260.3988\\\\0.2202\u00260.9752\u00260.0224\\\\-0.3846\u00260.1078\u0026-0.9168 \\end{bmatrix} \\iff \\begin{bmatrix} 0.2967251 \u00262.7186044 \u0026 0.0934307 \\end{bmatrix} $$ 3. Inverse kinematics # 3.1 逆运动学计算(标准DH参数) # 逆运动学是已知变换矩阵$_{6}^{0}T$(机械臂末端位置和姿态)，求六个关节角度。\n3.1.1 求解过程 # 参考文献：\nUR5机械臂正逆运动学解析-CSDN博客\n一种求UR机械臂逆运动学不受奇异位置影响的方法(附Matlab代码)_ur 运动学 sdh-CSDN博客\n3.1.2 求解公式 # $\\theta_1$(双解) $$ {\\theta_{1}=A\\tan2(m,n)-A\\tan2(\\mathrm{d}_{4},\\pm\\sqrt{m^{2}+n^{2}-d_{4}^{2}})}\\qquad(其中m^2+n^2-d_{4}^{2}\\geq0)\\\\ m = d_6a_y-p_y\\\\ n = a_xd_6-p_x $$ $\\theta_5$(双解) $$ {\\theta_5=\\pm\\arccos(a_xs_1-a_yc_1)}\\qquad(其中a_xs_1-a_yc_1\\leq1) $$ $\\theta_6$ $$ {\\theta_6=A\\tan2(m,n)-A\\tan2(s_5,0)}\\qquad(其中{s_5\\neq0})\\\\ m = n_xs_1-n_yc_1\\\\ n = o_xs_1-o_yc_1 $$ $\\theta_3$(双解) $$ \\begin{aligned} {\\theta_3=\\pm\\arccos(\\frac{m^2+n^2-{a_2}^2-{a_3}^2}{2a_2a_3})}\\qquad(其中{m^2+n^2\\leq(a_2+a_3)^2})\\\\ \u0026m= d_{5}(s_{6}(n_{x}c_{1}+n_{y}s_{1})+c_{6}(o_{x}c_{1}+o_{y}s_{1}))-d_6(a_xc_1+a_ys_1)+p_xc_1+p_ys_1\\\\ \u0026n=p_{z}-d_{1}-a_{z}d_{6}+d_{5}(o_{z}c_{6}+n_{z}s_{6}) \\end{aligned} $$ $\\theta_2$ $$ \\begin{aligned} \u0026{\\theta_{2}=A\\tan2(s_{2},c_{2})}\\\\ \u0026s_2=\\frac{(a_3c_3+a_2)n-a_3s_3m}{a_2^2+a_3^2+2a_2a_3c_3}\\\\ \u0026c_2=\\frac{m+a_3s_3s_2}{a_3c_3+a_2} \\end{aligned} $$ $\\theta_4$ $$ {\\theta_4=A\\tan2(-s_6(n_xc_1+n_ys_1)-c_6(o_xc_1+o_y s_1)\\;,\\;o_zc_6+n_zs_6)-\\theta_2-\\theta_3} $$ 算法求解到关节角： joint 1 joint 5 joint 6 joint 3 joint 2 joint 4 当前关节角产生解的个数 2 2 1 2 1 1 当前已有解的个数 2 4 4 8 8 8 3.1.3 机械臂奇异点 # 机械臂的奇异点（Singularity）是指在特定位置或姿态下，机械臂的运动能力受到限制或丧失的情况。在这些点上，机械臂的某些自由度变得不再独立，导致机器人无法在某些方向上移动或控制其末端执行器。\n奇异点的具体表现： 不可逆的运动丧失：在奇异点处，机械臂的某些自由度会出现退化，例如可能无法沿某个方向进行平移或旋转。 控制力丧失：如果机械臂的控制系统处于奇异点附近，它可能无法精确地控制末端执行器的位置或姿态。 动力学问题：在奇异点时，机械臂的关节力矩可能会变得极大或极小，导致系统不稳定或出现控制问题。 常见的奇异点类型： 逆向运动学奇异点：在某些位置或姿态下，解算机械臂的逆向运动学方程时可能没有解，或者解的数量不唯一。这种情况通常出现在机械臂的结构或操作空间的特殊配置下。 Jacobian矩阵的奇异性：Jacobian矩阵描述了机械臂关节速度与末端执行器速度之间的关系。如果Jacobian矩阵在某个点不可逆，表示该点为奇异点。此时，关节速度的控制可能无法完全传递到末端执行器的速度上。 如何避免或处理奇异点： 路径规划时避开奇异点：通过优化路径或选择合适的轨迹，避免机械臂在操作中经过奇异点。 使用冗余自由度：某些机械臂采用冗余自由度（例如额外的自由度或关节），使得在遇到奇异点时，机器人仍然能够继续运动，避免完全的运动丧失。 实时控制调整：通过实时监控和动态调整控制算法，使机械臂能够在接近奇异点时适当调整路径。 3.1.4 UR5奇异位置 # Youtube video here\n腕部奇异(Wrist Singularity) $$ {s_5=0} $$ $\\theta_5=0$，此时轴线$Z_4$和$Z_6$平行，逆运动学有无数解\n肘部奇异(Elbow Singularity) $$ {m^2+n^2-(a_2+a_3)^2=0}\\\\ \\begin{aligned} \u0026m= d_{5}(s_{6}(n_{x}c_{1}+n_{y}s_{1})+c_{6}(o_{x}c_{1}+o_{y}s_{1}))-d_6(a_xc_1+a_ys_1)+p_xc_1+p_ys_1\\\\ \u0026n=p_{z}-d_{1}-a_{z}d_{6}+d_{5}(o_{z}c_{6}+n_{z}s_{6}) \\end{aligned} $$ 关节234轴线共面，\n肩部奇异(Shoulder Singularity) $$ {m^2+n^2-d_{4}^{2}=0}\\\\ m = d_6a_y-p_y\\\\ n = a_xd_6-p_x $$ 关节56交点在$Z_1$$Z_2$平面内时，发生肩部奇异\n3.2 Matlab仿真验证 # 3.2.1 Matlab程序 # function theta = inverse_kinematics(T) %变换矩阵T已知 %SDH:标准DH参数表求逆解（解析解） %部分DH参数表如下，需要求解theta信息 %UR5 standard_DH parameter a=[0,-0.42500,-0.39225,0,0,0]; d=[0.089159,0,0,0.10915,0.09465,0.08230]; alpha=[pi/2,0,0,pi/2,-pi/2,0];% alpha没有用到,故此逆解程序只适合alpha=[pi/2,0,0,pi/2,-pi/2,0]的情况！ nx=T(1,1);ny=T(2,1);nz=T(3,1); ox=T(1,2);oy=T(2,2);oz=T(3,2); ax=T(1,3);ay=T(2,3);az=T(3,3); px=T(1,4);py=T(2,4);pz=T(3,4); %求解关节角1 m=d(6)*ay-py; n=ax*d(6)-px; theta1(1,1)=atan2(m,n)-atan2(d(4),sqrt(m^2+n^2-(d(4))^2)); theta1(1,2)=atan2(m,n)-atan2(d(4),-sqrt(m^2+n^2-(d(4))^2)); %求解关节角5 theta5(1,1:2)=acos(ax*sin(theta1)-ay*cos(theta1)); theta5(2,1:2)=-acos(ax*sin(theta1)-ay*cos(theta1)); %求解关节角6 mm=nx*sin(theta1)-ny*cos(theta1); nn=ox*sin(theta1)-oy*cos(theta1); %theta6=atan2(mm,nn)-atan2(sin(theta5),0); theta6(1,1:2)=atan2(mm,nn)-atan2(sin(theta5(1,1:2)),0); theta6(2,1:2)=atan2(mm,nn)-atan2(sin(theta5(2,1:2)),0); %求解关节角3 mmm(1,1:2)=d(5)*(sin(theta6(1,1:2)).*(nx*cos(theta1)+ny*sin(theta1))+cos(theta6(1,1:2)).*(ox*cos(theta1)+oy*sin(theta1))) ... -d(6)*(ax*cos(theta1)+ay*sin(theta1))+px*cos(theta1)+py*sin(theta1); nnn(1,1:2)=pz-d(1)-az*d(6)+d(5)*(oz*cos(theta6(1,1:2))+nz*sin(theta6(1,1:2))); mmm(2,1:2)=d(5)*(sin(theta6(2,1:2)).*(nx*cos(theta1)+ny*sin(theta1))+cos(theta6(2,1:2)).*(ox*cos(theta1)+oy*sin(theta1))) ... -d(6)*(ax*cos(theta1)+ay*sin(theta1))+px*cos(theta1)+py*sin(theta1); nnn(2,1:2)=pz-d(1)-az*d(6)+d(5)*(oz*cos(theta6(2,1:2))+nz*sin(theta6(2,1:2))); theta3(1:2,:)=acos((mmm.^2+nnn.^2-(a(2))^2-(a(3))^2)/(2*a(2)*a(3))); theta3(3:4,:)=-acos((mmm.^2+nnn.^2-(a(2))^2-(a(3))^2)/(2*a(2)*a(3))); %求解关节角2 mmm_s2(1:2,:)=mmm; mmm_s2(3:4,:)=mmm; nnn_s2(1:2,:)=nnn; nnn_s2(3:4,:)=nnn; s2=((a(3)*cos(theta3)+a(2)).*nnn_s2-a(3)*sin(theta3).*mmm_s2)./ ... ((a(2))^2+(a(3))^2+2*a(2)*a(3)*cos(theta3)); c2=(mmm_s2+a(3)*sin(theta3).*s2)./(a(3)*cos(theta3)+a(2)); theta2=atan2(s2,c2); %整理关节角1 5 6 3 2 theta(1:4,1)=theta1(1,1);theta(5:8,1)=theta1(1,2); theta(:,2)=[theta2(1,1),theta2(3,1),theta2(2,1),theta2(4,1),theta2(1,2),theta2(3,2),theta2(2,2),theta2(4,2)]\u0026#39;; theta(:,3)=[theta3(1,1),theta3(3,1),theta3(2,1),theta3(4,1),theta3(1,2),theta3(3,2),theta3(2,2),theta3(4,2)]\u0026#39;; theta(1:2,5)=theta5(1,1);theta(3:4,5)=theta5(2,1); theta(5:6,5)=theta5(1,2);theta(7:8,5)=theta5(2,2); theta(1:2,6)=theta6(1,1);theta(3:4,6)=theta6(2,1); theta(5:6,6)=theta6(1,2);theta(7:8,6)=theta6(2,2); %求解关节角4 theta(:,4)=atan2(-sin(theta(:,6)).*(nx*cos(theta(:,1))+ny*sin(theta(:,1)))-cos(theta(:,6)).* ... (ox*cos(theta(:,1))+oy*sin(theta(:,1))),oz*cos(theta(:,6))+nz*sin(theta(:,6)))-theta(:,2)-theta(:,3); end 3.2.2 关节角验证 # UR仿真器\n程序输入：\n$$ T =\\begin{bmatrix} -0.8965 \u0026 0.1933 \u0026 0.3988 \u0026 0.1727\\\\0.2202\u0026 0.9752 \u0026 0.0224 \u0026 -0.5555\\\\-0.3846 \u0026 0.1078 \u0026 -0.9168 \u0026 0.1110\\\\0 \u00260 \u0026 0 \u0026 1 \\end{bmatrix} $$程序输出：\n$$ \\begin{array}{cccccc} 93.1400 \u0026 -42.2188 \u0026 70.9064 \u0026 61.3424 \u0026 66.4600 \u0026 -164.4100 \\\\ 93.1400 \u0026 25.4187 \u0026 -70.9064 \u0026 135.5177 \u0026 66.4600 \u0026 -164.4100 \\\\ \\textcolor{yellow}{93.1400} \u0026 \\textcolor{yellow}{-62.6800} \u0026 \\textcolor{yellow}{108.2700} \u0026 \\textcolor{yellow}{-135.5600} \u0026 \\textcolor{yellow}{-66.4600} \u0026 \\textcolor{yellow}{15.5900} \\\\ 93.1400 \u0026 39.2446 \u0026 -108.2700 \u0026 -20.9446 \u0026 -66.4600 \u0026 15.5900 \\\\ -64.9617 \u0026 138.8163 \u0026 108.5565 \u0026 -148.1713 \u0026 111.7619 \u0026 39.2670 \\\\ -64.9617 \u0026 -119.0060 \u0026 -108.5565 \u0026 326.7641 \u0026 111.7619 \u0026 39.2670 \\\\ -64.9617 \u0026 156.0221 \u0026 70.6185 \u0026 -307.4390 \u0026 -111.7619 \u0026 219.2670 \\\\ -64.9617 \u0026 -136.6111 \u0026 -70.6185 \u0026 126.4311 \u0026 -111.7619 \u0026 219.2670 \\\\ \\end{array} $$期望关节角：[ 93.14 , -62.68 , 108.27 , -135.56 , -66.46 , 15.59]\n解算关节角度：[ 93.1400 , -62.6800 , 108.2700 , -135.5600 , -66.4600 , 15.5900]\nUR5机械臂工作空间分析 # 机械臂的工作空间限制了机械臂末端所能达到的空间大小,常见的工作空间分析的方法中有解析法、图解法、数值解法。其中数值解法也称为 “蒙特卡洛法”,是经典的求解机械臂工作空间的方法。本文采用蒙特卡洛法对机械臂的工作空间展开解析。\n蒙特卡洛法 # Matlab程序：\n% UR5 机械臂 DH 参数定义 % DH 参数：[theta d a alpha] DH_params = [ 0 0.08916 0 pi/2; 0 0 -0.425 0; 0 0 -0.39225 0; 0 0.10915 0 pi/2; 0 0.09465 0 -pi/2; 0 0.0823 0 0 ]; N = 50000; % 随机采样数量 q_limits = [-180, 180]; % 关节角范围（度） % 初始化存储位置 x = zeros(1, N); y = zeros(1, N); z = zeros(1, N); % 蒙特卡罗采样 for i = 1:N q = (q_limits(2) - q_limits(1)) * rand(1, 6) + q_limits(1); % 随机生成六个关节角 q = deg2rad(q); % 转换为弧度 % 计算正向运动学 T = eye(4); for j = 1:6 theta = q(j) + DH_params(j, 1); d = DH_params(j, 2); a = DH_params(j, 3); alpha = DH_params(j, 4); Tj = [ cos(theta) -sin(theta)*cos(alpha) sin(theta)*sin(alpha) a*cos(theta); sin(theta) cos(theta)*cos(alpha) -cos(theta)*sin(alpha) a*sin(theta); 0 sin(alpha) cos(alpha) d; 0 0 0 1 ]; T = T * Tj; end % 提取末端执行器位置 x(i) = T(1, 4); y(i) = T(2, 4); z(i) = T(3, 4); end % 绘制三维工作域 figure; scatter3(x, y, z, 1, \u0026#39;b\u0026#39;); xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); zlabel(\u0026#39;Z\u0026#39;); title(\u0026#39;UR5 机械臂工作域分析 (蒙特卡罗法)\u0026#39;); grid on; axis equal; % 绘制XY平面点云图 figure; scatter(x, y, 1, \u0026#39;r\u0026#39;); xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Y\u0026#39;); title(\u0026#39;UR5 XY平面工作域\u0026#39;); grid on; axis equal; % 绘制XZ平面点云图 figure; scatter(x, z, 1, \u0026#39;g\u0026#39;); xlabel(\u0026#39;X\u0026#39;); ylabel(\u0026#39;Z\u0026#39;); title(\u0026#39;UR5 XZ平面工作域\u0026#39;); grid on; axis equal; % 绘制YZ平面点云图 figure; scatter(y, z, 1, \u0026#39;m\u0026#39;); xlabel(\u0026#39;Y\u0026#39;); ylabel(\u0026#39;Z\u0026#39;); title(\u0026#39;UR5 YZ平面工作域\u0026#39;); grid on; axis equal; % 输出工作域范围 x_range = [min(x), max(x)]; y_range = [min(y), max(y)]; z_range = [min(z), max(z)]; fprintf(\u0026#39;X 方向工作域范围: [%f, %f]\\n\u0026#39;, x_range(1), x_range(2)); fprintf(\u0026#39;Y 方向工作域范围: [%f, %f]\\n\u0026#39;, y_range(1), y_range(2)); fprintf(\u0026#39;Z 方向工作域范围: [%f, %f]\\n\u0026#39;, z_range(1), z_range(2)); 结果分析：\nX 方向工作域范围(m): [-0.929379, 0.925462] Y 方向工作域范围(m): [-0.915354, 0.928719] Z 方向工作域范围(m): [-0.851616, 1.025654] UR5 CB3机械臂实际工作范围850mm\n","date":"28 December 2024","externalUrl":null,"permalink":"/blog/ur5-kinematic/","section":"Blog","summary":"","title":"UR5机械臂正逆运动学分析+Matlab仿真","type":"blog"},{"content":"","date":"17 December 2024","externalUrl":"https://blog.csdn.net/m0_60079093/article/details/144540588?spm=1001.2014.3001.5502","permalink":"/blog/universal_robots_ros2_driver4/","section":"Blog","summary":"Moveit2 Servo 与 MoveIt2 Trajectory Execution","title":"Universal_Robots_ROS2_Driver(4)","type":"blog"},{"content":"","date":"16 December 2024","externalUrl":"https://blog.csdn.net/m0_60079093/article/details/144513002?spm=1001.2014.3001.5502","permalink":"/blog/serial_port_protocol_structure/","section":"Blog","summary":"","title":"串口协议的三层结构(物理层、数据链路层、应用层)","type":"blog"},{"content":"","date":"9 December 2024","externalUrl":"https://blog.csdn.net/m0_60079093/article/details/144287207?spm=1001.2014.3001.5502","permalink":"/blog/universal_robots_ros2_driver3/","section":"Blog","summary":"双臂驱动(节点图 ，IP架构，控制系统通信架构，Ethernet与EtherCAT)","title":"Universal_Robots_ROS2_Driver(3)","type":"blog"},{"content":"","date":"14 November 2024","externalUrl":"https://blog.csdn.net/m0_60079093/article/details/143772217?spm=1001.2014.3001.5502","permalink":"/blog/universal_robots_ros2_driver2/","section":"Blog","summary":"实现了上层move_group接口，可以通过自定义节点控制机械臂。","title":"Universal_Robots_ROS2_Driver(2)","type":"blog"},{"content":"","date":"25 October 2024","externalUrl":"https://blog.csdn.net/m0_60079093/article/details/143218457?spm=1001.2014.3001.5502","permalink":"/blog/universal_robots_ros2_driver1/","section":"Blog","summary":"基于Universal_Robots_ROS2_Driver和UR_sim实现单个UR5机械臂仿真控制","title":"Universal_Robots_ROS2_Driver(1)","type":"blog"},{"content":"","date":"13 June 2022","externalUrl":null,"permalink":"/blog/","section":"Blog","summary":"","title":"Blog","type":"blog"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]