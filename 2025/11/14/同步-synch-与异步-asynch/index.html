<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="同步(sync)与异步(async)" />
    <meta name="hexo-theme-A4" content="v2.0.0" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.jpg">
    <title>Stocks</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery-bundle.min.css">


   
        
<link rel="stylesheet" href="/css/custom.css">

    
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkai/dist/LXGWWenKai-Regular/result.css' /> 
<meta name="generator" content="Hexo 8.1.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
    
    

    
    



    
        <style>
            .paper-main{
                max-width:  1200px;
            }
        </style>

    
    




    
    
    <style>
        body {
            background-image: url(/img/bg3.png);
            background-attachment: fixed;  /* 背景固定，不随页面滚动 */
            background-repeat: no-repeat;  /* 防止背景图片重复 */
            background-size: cover;       /* 背景自适应大小，覆盖整个背景 */
            background-position: center;   /* 背景居中显示 */
        }
        .paper {
            background-image: url(/img/bg3.png);
            background-attachment: fixed;  /* 背景固定，不随页面滚动 */
            background-repeat: no-repeat;  /* 防止背景图片重复 */
            background-size: cover;       /* 背景自适应大小，覆盖整个背景 */
            background-position: center;   /* 背景居中显示 */
        }  
    </style>



    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        
            
                <div class="left-toc-container">
                    <nav id="toc" class="bs-docs-sidebar"></nav>
                </div>
            
        
        <div class="paper">

            

            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <style>
            .header-img {
                width: 56px;
                height: auto;
                object-fit: cover; /* 保持图片比例 */
                transition: transform 0.3s ease-in-out; 
                border-radius: 50%; 
            }
            
        </style>
        <img 
            alt="^-^" 
            cache-control="max-age=86400" 
            class="header-img" 
            src="/img/favicon.jpg" 
        />
        <div class="header-content">
            <a class="logo" href="/">Stocks</a> 
            <span class="description">嵌入式系统开发 | 机器人算法</span> 
        </div>
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">🏠 首页</a></li>
            
        
            
                <li><a href="/list/">📝文章</a></li>
            
        
            
                <li><a href="/tags/">📌标签</a></li>
            
        
            
                <li><a href="/categories/">📁分类</a></li>
            
        
            
                <li><a href="/about/">🌟关于</a></li>
            
        
    </ul>
</div>

                    
                    

                    
                    

                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    同步(sync)与异步(async)
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2025-11-15</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：1.5k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：5分钟</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span id="busuanzi_container_page_pv">
                        阅读量：<span id="busuanzi_value_page_pv"></span>次
                    </span>
                
            </div>
    

    <div class="post-md">
        
        <div class=".article-gallery"><blockquote>
<p>参考文献：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/270428703">从小白到高手，你需要理解同步与异步</a></p>
</blockquote>
<p>同步和异步是编程中两种不同的<strong>执行模式</strong>，主要区别在于任务的执行顺序和是否阻塞后续代码。</p>
<h4 id="同步">同步</h4>
<ul>
<li><p><strong>定义</strong>：同步操作是指调用方发起一个操作后，必须等待该操作执行完成并返回结果后，才能继续执行后续代码。<strong>这是一种线性的、顺序执行的方式。</strong></p></li>
<li><p><strong>核心特征</strong>：<span style="color: red;"><strong>阻塞</strong></span>。调用方线程的活动会因等待操作完成而被暂停。同步编程对程序员来说是最自然最容易理解的，但是在一些场景下并不高效。</p></li>
<li><p><strong>适用场景</strong>：CPU密集型任务(复杂的数学计算、图像处理、数据压缩/加密),无并发需求的任务，可快速完成的简单操作(内存中的数据查找、简单的条件判断)。
<strong>当任务本质上是顺序执行的，主要是计算，而非I/O时，同步是更简单、更高效的选择。</strong></p></li>
</ul>
<h6 id="同一线程内同步调用">1. 同一线程内同步调用</h6>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">funcA</span>() {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用funcB()</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">funcB</span>(); <span class="comment">// 等待函数funcB执行完成</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续接下来的流程</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<center>
<a href="1.jpg" class="gallery-item" style="box-shadow: none;"> <img src="1.jpg" width="40%"></a>
</center>
<p>在funcB运行期间funcA什么都做不了，这就是典型的同步。<strong>一般来说，像这种同步调用，funcA和funcB是运行在同一个线程中的</strong>，这是最为常见的情况。</p>
<h6 id="线程间同步调用">2. 线程间同步调用</h6>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read_sync</span>(file, buf);  <span class="comment">// 阻塞式I/O</span></span><br><span class="line"><span class="comment">// 主程序暂停运行，只有当read函数返回后程序才可以被继续执行</span></span><br></pre></td></tr></tbody></table></figure>
<center>
<a href="2.jpg" class="gallery-item" style="box-shadow: none;"> <img src="2.jpg" width="40%"></a>
</center>
<p>当然，这也是同步调用，但是和上面的同步调用不同的是，函数和被调函数运行在不同的线程中。因此我们可以得出结论，<strong>同步调用和函数与被调函数是否运行在同一个线程是没有关系的。</strong></p>
<hr>
<h4 id="异步">异步</h4>
<ul>
<li><p><strong>定义</strong>：异步操作是指调用方发起一个操作后，无需等待该操作完成，可以立即返回并继续执行后续代码。被发起的操作会在“后台”独立执行，并通过某种机制（<strong>如回调函数、Promise、事件</strong>）在将来某个时刻通知调用方其完成状态和结果。</p></li>
<li><p><strong>核心特征</strong>：<span style="color: red;"><strong>非阻塞</strong></span>。调用方线程的活动在发起操作后不会被暂停。</p></li>
<li><p><strong>适用场景</strong>：I/O密集型应用(Web服务器/API网关、数据库客户端),图形用户界面程序，高并发、高吞吐量的网络服务。</p></li>
</ul>
<p><strong>当应用需要处理大量并发连接，或者需要避免因等待（尤其是I/O等待）而阻塞主线程时，异步是必不可少的选择。</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read_async</span>(file, buff);</span><br><span class="line"><span class="comment">// read函数立即返回,不会阻塞当前程序</span></span><br></pre></td></tr></tbody></table></figure>
<center>
<a href="3.jpg" class="gallery-item" style="box-shadow: none;"> <img src="3.jpg" width="40%"></a>
</center>
<p><strong>异步调用中调用方怎知到被调函数是否执行完成呢？(即上图中Notify的实现方式)</strong></p>
<ol type="1">
<li><strong>通知机制</strong>，也就是说当任务执行完成后发送信号用来通知调用方任务完成。注意这里的信号就有很多实现方式了，Linux中的signal，或者使用信号量等机制都可以实现。</li>
<li><strong>回调函数</strong>，调用函数时通过引入回调函数，可以在被调函数结束时刻调用回调函数通知主程序(或者获取结果)。</li>
</ol>
<h6 id="同一线程内异步调用">1. 同一线程内异步调用</h6>
<p>同一线程内异步调用指在单一线程中通过事件循环（event loop）或任务队列实现的异步机制：调用方不会被阻塞，操作完成后由事件循环在同一线程中调度回调或继续执行后续任务。常见于浏览器/Node.js 的单线程模型、以及基于单线程事件循环的网络库（如 libuv、boost::asio 的单线程运行方式）。</p>
<p>要点：</p>
<ul>
<li><p>不会产生额外线程，避免线程切换和锁竞争；</p></li>
<li><p>通过事件队列、定时器、I/O 完成端口或回调/微任务（microtask）调度任务；</p></li>
<li><p>回调在同一线程中执行，能简化状态管理，但长时间运行的任务会阻塞事件循环，影响其它任务执行。</p></li>
</ul>
<p>示例（伪 C++：单线程事件循环与任务入队）：
</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的事件循环示意</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_task</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; t)</span> </span>{ tasks.<span class="built_in">push</span>(std::<span class="built_in">move</span>(t)); }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_event_loop</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">while</span> (!tasks.<span class="built_in">empty</span>()) {</span><br><span class="line">    <span class="keyword">auto</span> t = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>()); tasks.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">t</span>(); <span class="comment">// 在同一线程执行</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>使用场景：GUI 主线程、单线程网络服务、高并发 I/O 的协作式调度等。</p>
<h6 id="线程间异步调用">2. 线程间异步调用</h6>
<p>线程间异步调用指把耗时或阻塞的工作交给另一个线程（或线程池）执行，调用方立即返回，任务完成后通过回调、future/promise、条件变量或消息队列通知调用方或将结果传回。典型于多线程并行计算、后台 I/O 或阻塞操作的隔离。</p>
<p>要点：</p>
<ul>
<li><p>可以并行利用多核 CPU，避免主线程被阻塞；</p></li>
<li><p>回调通常在工作线程中执行——若结果需要在主线程处理（如 UI 更新），必须通过线程间消息传递或任务调度回主线程；</p></li>
<li><p>需注意同步、数据竞争、对象生命周期和异常传播。</p></li>
</ul>
<p>示例（C++：用 std::thread + 回调）：
</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_work_async</span><span class="params">(std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; cb)</span> </span>{</span><br><span class="line">  std::<span class="built_in">thread</span>([cb=std::<span class="built_in">move</span>(cb)](){</span><br><span class="line">    <span class="type">int</span> result = <span class="comment">/* ...耗时计算... */</span> <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">cb</span>(result); <span class="comment">// 在工作线程中调用回调</span></span><br><span class="line">  }).<span class="built_in">detach</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>示例（C++：使用 std::future/std::async 获取结果）：
</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(std::launch::async, [](){ <span class="keyword">return</span> <span class="built_in">heavy_compute</span>(); });</span><br><span class="line"><span class="comment">// 主线程可以继续做其它事</span></span><br><span class="line"><span class="type">int</span> res = fut.<span class="built_in">get</span>(); <span class="comment">// 在需要时阻塞等待结果</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>注意事项：</p>
<ul>
<li><p>回调在工作线程执行时不要直接访问仅限主线程的资源（例如 GUI 元素）；</p></li>
<li><p>若需在主线程处理结果，应将结果通过线程安全队列或 post/postMessage 等机制转回主线程；</p></li>
<li><p>谨慎处理异常、对象寿命和同步（使用 mutex、atomic、condition_variable 等）。</p></li>
</ul>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2025-11-14</span>
            
                <span>该篇文章被 Stocks yuan</span>
            
            
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/'>
                            编程模型与程序设计
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="/2025/11/14/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0Callback/">回调函数Callback</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>




                    

                    <div class="footer">
    
        <span> 
            © 2025 stocks-yuan 

            
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery/lightgallery.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 

                </div>
            
            
                <!-- 回到顶部的按钮-->
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>
<script src="/js/emojiHandler.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        wrapEmojis('.paper');
    });
</script>
